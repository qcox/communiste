return function(a,b)local c=8116484168865069;local d=212;local e;function encrypt(f,type)if type=="encode"then if not e then e={}for g=0,127 do local h=-1;repeat h=h+2 until h*(2*g+1)%256==1;e[g]=h end end;local i,j=c,16384+d;return f:gsub(".",function(k)local l=i%274877906944;local m=(i-l)/274877906944;local g=m%128;k=k:byte()local n=(k*e[g]-(m-g)/128)%256;i=l*j+m+n+k;return"%02x":format(n)end)else local i,j=c,16384+d;return f:gsub("%x%x",function(n)local l=i%274877906944;local m=(i-l)/274877906944;local g=m%128;n=tonumber(n,16)local k=(n+(m-g)/128)*(2*g+1)%256;i=l*j+m+n+k;return string.char(k)end)end end;if a=="BkVYmuYEl877wt9A6B3T"then local o={}local p={}local q={}local r={}local s={}local t={}local u=8;local function v(w)if not w then error("assertion failed!")end end;function o:make_getS(y)local z=y;return function()if not z then return nil end;local A=z;z=nil;return A end end;function o:make_getF(B)local C=512;local D=1;return function()local y=B:sub(D,D+C-1)D=math.min(#B+1,D+C)return y end end;function o:init(E,A)if not E then return end;local F={}F.reader=E;F.data=A or""F.name=name;if not A or A==""then F.n=0 else F.n=#A end;F.p=0;return F end;function o:fill(F)local y=F.reader()F.data=y;if not y or y==""then return"EOZ"end;F.n,F.p=#y-1,1;return string.sub(y,1,1)end;function o:zgetc(F)local G,H=F.n,F.p+1;if G>0 then F.n,F.p=G-1,H;return string.sub(F.data,H,H)else return self:fill(F)end end;q.RESERVED=[[
        TK_AND and
        TK_BREAK break
        TK_DO do
        TK_ELSE else
        TK_ELSEIF elseif
        TK_END end
        TK_FALSE false
        TK_FOR for
        TK_FUNCTION function
        TK_IF if
        TK_IN in
        TK_LOCAL local
        TK_NIL nil
        TK_NOT not
        TK_OR or
        TK_REPEAT repeat
        TK_RETURN return
        TK_THEN then
        TK_TRUE true
        TK_UNTIL until
        TK_WHILE while
        TK_CONCAT ..
        TK_DOTS ...
        TK_EQ ==
        TK_GE >=
        TK_LE <=
        TK_NE ~=
        TK_NAME <name>
        TK_NUMBER <number>
        TK_STRING <string>
        TK_EOS <eof>]]q.MAXSRC=80;q.MAX_INT=2147483645;q.LUA_QS="'%s'"q.LUA_COMPAT_LSTR=1;function q:init()local I,J={},{}for K in string.gmatch(self.RESERVED,"[^\n]+")do local L,L,M,f=string.find(K,"(%S+)%s+(%S+)")I[M]=f;J[f]=M end;self.tokens=I;self.enums=J end;function q:chunkid(B,N)local O;local P=string.sub(B,1,1)if P=="="then O=string.sub(B,2,N)else if P=="@"then B=string.sub(B,2)N=N-#" '...' "local Q=#B;O=""if Q>N then B=string.sub(B,1+Q-N)O=O.."..."end;O=O..B else local R=string.find(B,"[\n\r]")R=R and R-1 or#B;N=N-#" [string \"...\"] "if R>N then R=N end;O="[string \""if R<#B then O=O..string.sub(B,1,R).."..."else O=O..B end;O=O.."\"]"end end;return O end;function q:token2str(S,T)if string.sub(T,1,3)~="TK_"then if string.find(T,"%c")then return string.format("char(%d)",string.byte(T))end;return T else return self.tokens[T]end end;function q:lexerror(S,U,T)local function V(S,T)if T=="TK_NAME"or T=="TK_STRING"or T=="TK_NUMBER"then return S.buff else return self:token2str(S,T)end end;local y=self:chunkid(S.source,self.MAXSRC)local U=string.format("%s:%d: %s",y,S.linenumber,U)if T then U=string.format("%s near "..self.LUA_QS,U,V(S,T))end;error(U)end;function q:syntaxerror(S,U)self:lexerror(S,U,S.t.token)end;function q:currIsNewline(S)return S.current=="\n"or S.current=="\r"end;function q:inclinenumber(S)local W=S.current;self:nextc(S)if self:currIsNewline(S)and S.current~=W then self:nextc(S)end;S.linenumber=S.linenumber+1;if S.linenumber>=self.MAX_INT then self:syntaxerror(S,"chunk has too many lines")end end;function q:setinput(l,S,F,B)if not S then S={}end;if not S.lookahead then S.lookahead={}end;if not S.t then S.t={}end;S.decpoint="."S.L=l;S.lookahead.token="TK_EOS"S.z=F;S.fs=nil;S.linenumber=1;S.lastline=1;S.source=B;self:nextc(S)end;function q:check_next(S,X)if not string.find(X,S.current,1,1)then return false end;self:save_and_next(S)return true end;function q:next(S)S.lastline=S.linenumber;if S.lookahead.token~="TK_EOS"then S.t.seminfo=S.lookahead.seminfo;S.t.token=S.lookahead.token;S.lookahead.token="TK_EOS"else S.t.token=self:llex(S,S.t)end end;function q:lookahead(S)S.lookahead.token=self:llex(S,S.lookahead)end;function q:nextc(S)local n=o:zgetc(S.z)S.current=n;return n end;function q:save(S,n)local y=S.buff;S.buff=y..n end;function q:save_and_next(S)self:save(S,S.current)return self:nextc(S)end;function q:str2d(Y)local Z=tonumber(Y)if Z then return Z end;if string.lower(string.sub(Y,1,2))=="0x"then Z=tonumber(Y,16)if Z then return Z end end;return nil end;function q:buffreplace(S,_,a0)local Z,y="",S.buff;for H=1,#y do local n=string.sub(y,H,H)if n==_ then n=a0 end;Z=Z..n end;S.buff=Z end;function q:trydecpoint(S,a1)local W=S.decpoint;self:buffreplace(S,W,S.decpoint)local a2=self:str2d(S.buff)a1.seminfo=a2;if not a2 then self:buffreplace(S,S.decpoint,".")self:lexerror(S,"malformed number","TK_NUMBER")end end;function q:read_numeral(S,a1)repeat self:save_and_next(S)until string.find(S.current,"%D")and S.current~="."if self:check_next(S,"Ee")then self:check_next(S,"+-")end;while string.find(S.current,"^%w$")or S.current=="_"do self:save_and_next(S)end;self:buffreplace(S,".",S.decpoint)local a2=self:str2d(S.buff)a1.seminfo=a2;if not a2 then self:trydecpoint(S,a1)end end;function q:skip_sep(S)local a3=0;local Y=S.current;self:save_and_next(S)while S.current=="="do self:save_and_next(S)a3=a3+1 end;return S.current==Y and a3 or-a3-1 end;function q:read_long_string(S,a1,a4)local a5=0;self:save_and_next(S)if self:currIsNewline(S)then self:inclinenumber(S)end;while true do local n=S.current;if n=="EOZ"then self:lexerror(S,a1 and"unfinished long string"or"unfinished long comment","TK_EOS")elseif n=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(S)==a4 then self:save_and_next(S)a5=a5+1;if self.LUA_COMPAT_LSTR==1 then if a4==0 then self:lexerror(S,"nesting of [[...]] is deprecated","[")end end end end elseif n=="]"then if self:skip_sep(S)==a4 then self:save_and_next(S)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then a5=a5-1;if a4==0 and a5>=0 then break end end;break end elseif self:currIsNewline(S)then self:save(S,"\n")self:inclinenumber(S)if not a1 then S.buff=""end else if a1 then self:save_and_next(S)else self:nextc(S)end end end;if a1 then local H=3+a4;a1.seminfo=string.sub(S.buff,H,-H)end end;function q:read_string(S,a6,a1)self:save_and_next(S)while S.current~=a6 do local n=S.current;if n=="EOZ"then self:lexerror(S,"unfinished string","TK_EOS")elseif self:currIsNewline(S)then self:lexerror(S,"unfinished string","TK_STRING")elseif n=="\\"then n=self:nextc(S)if self:currIsNewline(S)then self:save(S,"\n")self:inclinenumber(S)elseif n~="EOZ"then local a7=string.find("abfnrtv",n,1,1)if a7 then self:save(S,string.sub("\a\b\f\n\r\t\v",a7,a7))self:nextc(S)elseif not string.find(n,"%d")then self:save_and_next(S)else n,a7=0,0;repeat n=10*n+S.current;self:nextc(S)a7=a7+1 until a7>=3 or not string.find(S.current,"%d")if n>255 then self:lexerror(S,"escape sequence too large","TK_STRING")end;self:save(S,string.char(n))end end else self:save_and_next(S)end end;self:save_and_next(S)a1.seminfo=string.sub(S.buff,2,-2)end;function q:llex(S,a1)S.buff=""while true do local n=S.current;if self:currIsNewline(S)then self:inclinenumber(S)elseif n=="-"then n=self:nextc(S)if n~="-"then return"-"end;local a4=-1;if self:nextc(S)=='['then a4=self:skip_sep(S)S.buff=""end;if a4>=0 then self:read_long_string(S,nil,a4)S.buff=""else while not self:currIsNewline(S)and S.current~="EOZ"do self:nextc(S)end end elseif n=="["then local a4=self:skip_sep(S)if a4>=0 then self:read_long_string(S,a1,a4)return"TK_STRING"elseif a4==-1 then return"["else self:lexerror(S,"invalid long string delimiter","TK_STRING")end elseif n=="="then n=self:nextc(S)if n~="="then return"="else self:nextc(S)return"TK_EQ"end elseif n=="<"then n=self:nextc(S)if n~="="then return"<"else self:nextc(S)return"TK_LE"end elseif n==">"then n=self:nextc(S)if n~="="then return">"else self:nextc(S)return"TK_GE"end elseif n=="~"then n=self:nextc(S)if n~="="then return"~"else self:nextc(S)return"TK_NE"end elseif n=="\""or n=="'"then self:read_string(S,n,a1)return"TK_STRING"elseif n=="."then n=self:save_and_next(S)if self:check_next(S,".")then if self:check_next(S,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(n,"%d")then return"."else self:read_numeral(S,a1)return"TK_NUMBER"end elseif n=="EOZ"then return"TK_EOS"else if string.find(n,"%s")then self:nextc(S)elseif string.find(n,"%d")then self:read_numeral(S,a1)return"TK_NUMBER"elseif string.find(n,"[_%a]")then repeat n=self:save_and_next(S)until n=="EOZ"or not string.find(n,"[_%w]")local a8=S.buff;local M=self.enums[a8]if M then return M end;a1.seminfo=a8;return"TK_NAME"else self:nextc(S)return n end end end end;r.OpMode={iABC=0,iABx=1,iAsBx=2}r.SIZE_C=9;r.SIZE_B=9;r.SIZE_Bx=r.SIZE_C+r.SIZE_B;r.SIZE_A=8;r.SIZE_OP=6;r.POS_OP=0;r.POS_A=r.POS_OP+r.SIZE_OP;r.POS_C=r.POS_A+r.SIZE_A;r.POS_B=r.POS_C+r.SIZE_C;r.POS_Bx=r.POS_C;r.MAXARG_Bx=math.ldexp(1,r.SIZE_Bx)-1;r.MAXARG_sBx=math.floor(r.MAXARG_Bx/2)r.MAXARG_A=math.ldexp(1,r.SIZE_A)-1;r.MAXARG_B=math.ldexp(1,r.SIZE_B)-1;r.MAXARG_C=math.ldexp(1,r.SIZE_C)-1;function r:GET_OPCODE(a7)return self.ROpCode[a7.OP]end;function r:SET_OPCODE(a7,a9)a7.OP=self.OpCode[a9]end;function r:GETARG_A(a7)return a7.A end;function r:SETARG_A(a7,aa)a7.A=aa end;function r:GETARG_B(a7)return a7.B end;function r:SETARG_B(a7,z)a7.B=z end;function r:GETARG_C(a7)return a7.C end;function r:SETARG_C(a7,z)a7.C=z end;function r:GETARG_Bx(a7)return a7.Bx end;function r:SETARG_Bx(a7,z)a7.Bx=z end;function r:GETARG_sBx(a7)return a7.Bx-self.MAXARG_sBx end;function r:SETARG_sBx(a7,z)a7.Bx=z+self.MAXARG_sBx end;function r:CREATE_ABC(a9,ab,z,n)return{OP=self.OpCode[a9],A=ab,B=z,C=n}end;function r:CREATE_ABx(a9,ab,ac)return{OP=self.OpCode[a9],A=ab,Bx=ac}end;function r:CREATE_Inst(n)local a9=n%64;n=(n-a9)/64;local ab=n%256;n=(n-ab)/256;return self:CREATE_ABx(a9,ab,n)end;function r:Instruction(a7)if a7.Bx then a7.C=a7.Bx%512;a7.B=(a7.Bx-a7.C)/512 end;local ad=a7.A*64+a7.OP;local ae=ad%256;ad=a7.C*64+(ad-ae)/256;local af=ad%256;ad=a7.B*128+(ad-af)/256;local ag=ad%256;local ah=(ad-ag)/256;return string.char(ae,af,ag,ah)end;function r:DecodeInst(x)local ai=string.byte;local a7={}local ad=ai(x,1)local aj=ad%64;a7.OP=aj;ad=ai(x,2)*4+(ad-aj)/64;local ab=ad%256;a7.A=ab;ad=ai(x,3)*4+(ad-ab)/256;local n=ad%512;a7.C=n;a7.B=ai(x,4)*2+(ad-n)/512;local ak=self.OpMode[tonumber(string.sub(self.opmodes[aj+1],7,7))]if ak~="iABC"then a7.Bx=a7.B*512+a7.C end;return a7 end;r.BITRK=math.ldexp(1,r.SIZE_B-1)function r:ISK(x)return x>=self.BITRK end;function r:INDEXK(al)return x-self.BITRK end;r.MAXINDEXRK=r.BITRK-1;function r:RKASK(x)return x+self.BITRK end;r.NO_REG=r.MAXARG_A;r.opnames={}r.OpCode={}r.ROpCode={}local a7=0;for K in string.gmatch([[
        MOVE LOADK LOADBOOL LOADNIL GETUPVAL
        GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
        NEWTABLE SELF ADD SUB MUL
        DIV MOD POW UNM NOT
        LEN CONCAT JMP EQ LT
        LE TEST TESTSET CALL TAILCALL
        RETURN FORLOOP FORPREP TFORLOOP SETLIST
        CLOSE CLOSURE VARARG]],"%S+")do local G="OP_"..K;r.opnames[a7]=K;r.OpCode[G]=a7;r.ROpCode[a7]=G;a7=a7+1 end;r.NUM_OPCODES=a7;r.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function r:getOpMode(k)return self.opmodes[self.OpCode[k]]%4 end;function r:getBMode(k)return math.floor(self.opmodes[self.OpCode[k]]/16)%4 end;function r:getCMode(k)return math.floor(self.opmodes[self.OpCode[k]]/4)%4 end;function r:testAMode(k)return math.floor(self.opmodes[self.OpCode[k]]/64)%2 end;function r:testTMode(k)return math.floor(self.opmodes[self.OpCode[k]]/128)end;r.LFIELDS_PER_FLUSH=50;local function ak(am,ab,z,n,k)local r=r;return am*128+ab*64+r.OpArgMask[z]*16+r.OpArgMask[n]*4+r.OpMode[k]end;r.opmodes={ak(0,1,"OpArgK","OpArgN","iABx"),ak(0,1,"OpArgU","OpArgU","iABC"),ak(0,1,"OpArgR","OpArgN","iABC"),ak(0,1,"OpArgU","OpArgN","iABC"),ak(0,1,"OpArgK","OpArgN","iABx"),ak(0,1,"OpArgR","OpArgK","iABC"),ak(0,0,"OpArgK","OpArgN","iABx"),ak(0,0,"OpArgU","OpArgN","iABC"),ak(0,0,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgU","OpArgU","iABC"),ak(0,1,"OpArgR","OpArgK","iABC"),ak(0,1,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgK","OpArgK","iABC"),ak(0,1,"OpArgR","OpArgN","iABC"),ak(0,1,"OpArgR","OpArgN","iABC"),ak(0,1,"OpArgR","OpArgN","iABC"),ak(0,1,"OpArgR","OpArgR","iABC"),ak(0,0,"OpArgR","OpArgN","iAsBx"),ak(1,0,"OpArgK","OpArgK","iABC"),ak(1,0,"OpArgK","OpArgK","iABC"),ak(1,0,"OpArgK","OpArgK","iABC"),ak(1,1,"OpArgR","OpArgU","iABC"),ak(1,1,"OpArgR","OpArgU","iABC"),ak(0,1,"OpArgU","OpArgU","iABC"),ak(0,1,"OpArgU","OpArgU","iABC"),ak(0,0,"OpArgU","OpArgN","iABC"),ak(0,1,"OpArgR","OpArgN","iAsBx"),ak(0,1,"OpArgR","OpArgN","iAsBx"),ak(1,0,"OpArgN","OpArgU","iABC"),ak(0,0,"OpArgU","OpArgU","iABC"),ak(0,0,"OpArgN","OpArgN","iABC"),ak(0,1,"OpArgU","OpArgN","iABx"),ak(0,1,"OpArgU","OpArgN","iABC")}r.opmodes[0]=ak(0,1,"OpArgR","OpArgN","iABC")s.LUA_SIGNATURE="\27Lua"s.LUA_TNUMBER=3;s.LUA_TSTRING=4;s.LUA_TNIL=0;s.LUA_TBOOLEAN=1;s.LUA_TNONE=-1;s.LUAC_VERSION=0x51;s.LUAC_FORMAT=0;s.LUAC_HEADERSIZE=12;function s:make_setS()local y={}y.data=""local an=function(Y,y)if not Y then return 0 end;y.data=y.data..Y;return 0 end;return an,y end;function s:make_setF(ao)local y={}y.h=io.open(ao,"wb")if not y.h then return nil end;local an=function(Y,y)if not y.h then return 0 end;if not Y then if y.h:close()then return 0 end else if y.h:write(Y)then return 0 end end;return 1 end;return an,y end;function s:ttype(a9)local ap=type(a9.value)if ap=="number"then return self.LUA_TNUMBER elseif ap=="string"then return self.LUA_TSTRING elseif ap=="nil"then return self.LUA_TNIL elseif ap=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function s:from_double(x)local function aq(K)local n=K%256;return(K-n)/256,string.char(n)end;local ar=0;if x<0 then ar=1;x=-x end;local as,at=math.frexp(x)if x==0 then as,at=0,0 elseif x==1/0 then as,at=0,2047 else as=(as*2-1)*math.ldexp(0.5,53)at=at+1022 end;local K,ai=""x=math.floor(as)for a7=1,6 do x,ai=aq(x)K=K..ai end;x,ai=aq(at*16+x)K=K..ai;x,ai=aq(ar*128+x)K=K..ai;return K end;function s:from_int(x)local K=""x=math.floor(x)if x<0 then x=4294967296+x end;for a7=1,4 do local n=x%256;K=K..string.char(n)x=math.floor(x/256)end;return K end;function s:DumpBlock(z,au)if au.status==0 then au.status=au.write(z,au.data)end end;function s:DumpChar(av,au)self:DumpBlock(string.char(av),au)end;function s:DumpInt(x,au)self:DumpBlock(self:from_int(x),au)end;function s:DumpSizeT(x,au)self:DumpBlock(self:from_int(x),au)if u==8 then self:DumpBlock(self:from_int(0),au)end end;function s:DumpNumber(x,au)self:DumpBlock(self:from_double(x),au)end;function s:DumpString(Y,au)if Y==nil then self:DumpSizeT(0,au)else Y=Y.."\0"self:DumpSizeT(#Y,au)self:DumpBlock(Y,au)end end;function s:DumpCode(aw,au)local G=aw.sizecode;self:DumpInt(G,au)for a7=0,G-1 do self:DumpBlock(r:Instruction(aw.code[a7]),au)end end;function s:DumpConstants(aw,au)local G=aw.sizek;self:DumpInt(G,au)for a7=0,G-1 do local a9=aw.k[a7]local ap=self:ttype(a9)self:DumpChar(ap,au)if ap==self.LUA_TNIL then elseif ap==self.LUA_TBOOLEAN then self:DumpChar(a9.value and 1 or 0,au)elseif ap==self.LUA_TNUMBER then self:DumpNumber(a9.value,au)elseif ap==self.LUA_TSTRING then self:DumpString(a9.value,au)else end end;G=aw.sizep;self:DumpInt(G,au)for a7=0,G-1 do self:DumpFunction(aw.p[a7],aw.source,au)end end;function s:DumpDebug(aw,au)local G;G=au.strip and 0 or aw.sizelineinfo;self:DumpInt(G,au)for a7=0,G-1 do self:DumpInt(aw.lineinfo[a7],au)end;G=au.strip and 0 or aw.sizelocvars;self:DumpInt(G,au)for a7=0,G-1 do self:DumpString(aw.locvars[a7].varname,au)self:DumpInt(aw.locvars[a7].startpc,au)self:DumpInt(aw.locvars[a7].endpc,au)end;G=au.strip and 0 or aw.sizeupvalues;self:DumpInt(G,au)for a7=0,G-1 do self:DumpString(aw.upvalues[a7],au)end end;function s:DumpFunction(aw,H,au)local B=aw.source;if B==H or au.strip then B=nil end;self:DumpString(B,au)self:DumpInt(aw.lineDefined,au)self:DumpInt(aw.lastlinedefined,au)self:DumpChar(aw.nups,au)self:DumpChar(aw.numparams,au)self:DumpChar(aw.is_vararg,au)self:DumpChar(aw.maxstacksize,au)self:DumpCode(aw,au)self:DumpConstants(aw,au)self:DumpDebug(aw,au)end;function s:DumpHeader(au)local ax=self:header()assert(#ax==self.LUAC_HEADERSIZE)self:DumpBlock(ax,au)end;function s:header()local x=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,x,4,u,4,8,0)end;function s:dump(l,aw,ay,A,az)local au={}au.L=l;au.write=ay;au.data=A;au.strip=az;au.status=0;self:DumpHeader(au)self:DumpFunction(aw,nil,au)au.write(nil,au.data)return au.status end;t.MAXSTACK=250;function t:ttisnumber(a9)if a9 then return type(a9.value)=="number"else return false end end;function t:nvalue(a9)return a9.value end;function t:setnilvalue(a9)a9.value=nil end;function t:setsvalue(a9,x)a9.value=x end;t.setnvalue=t.setsvalue;t.sethvalue=t.setsvalue;t.setbvalue=t.setsvalue;function t:numadd(ab,z)return ab+z end;function t:numsub(ab,z)return ab-z end;function t:nummul(ab,z)return ab*z end;function t:numdiv(ab,z)return ab/z end;function t:nummod(ab,z)return ab%z end;function t:numpow(ab,z)return ab^z end;function t:numunm(ab)return-ab end;function t:numisnan(ab)return not ab==ab end;t.NO_JUMP=-1;t.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}t.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function t:getcode(aA,aB)return aA.f.code[aB.info]end;function t:codeAsBx(aA,a9,aC,aD)return self:codeABx(aA,a9,aC,aD+r.MAXARG_sBx)end;function t:setmultret(aA,aB)self:setreturns(aA,aB,p.LUA_MULTRET)end;function t:hasjumps(aB)return aB.t~=aB.f end;function t:isnumeral(aB)return aB.k=="VKNUM"and aB.t==self.NO_JUMP and aB.f==self.NO_JUMP end;function t:_nil(aA,_,G)if aA.pc>aA.lasttarget then if aA.pc==0 then if _>=aA.nactvar then return end else local aE=aA.f.code[aA.pc-1]if r:GET_OPCODE(aE)=="OP_LOADNIL"then local aF=r:GETARG_A(aE)local aG=r:GETARG_B(aE)if aF<=_ and _<=aG+1 then if _+G-1>aG then r:SETARG_B(aE,_+G-1)end;return end end end end;self:codeABC(aA,"OP_LOADNIL",_,_+G-1,0)end;function t:jump(aA)local aH=aA.jpc;aA.jpc=self.NO_JUMP;local aI=self:codeAsBx(aA,"OP_JMP",0,self.NO_JUMP)aI=self:concat(aA,aI,aH)return aI end;function t:ret(aA,P,aJ)self:codeABC(aA,"OP_RETURN",P,aJ+1,0)end;function t:condjump(aA,aj,aC,aK,aL)self:codeABC(aA,aj,aC,aK,aL)return self:jump(aA)end;function t:fixjump(aA,aM,aN)local aO=aA.f.code[aM]local aP=aN-(aM+1)v(aN~=self.NO_JUMP)if math.abs(aP)>r.MAXARG_sBx then q:syntaxerror(aA.ls,"control structure too long")end;r:SETARG_sBx(aO,aP)end;function t:getlabel(aA)aA.lasttarget=aA.pc;return aA.pc end;function t:getjump(aA,aM)local aP=r:GETARG_sBx(aA.f.code[aM])if aP==self.NO_JUMP then return self.NO_JUMP else return aM+1+aP end end;function t:getjumpcontrol(aA,aM)local aQ=aA.f.code[aM]local aR=aA.f.code[aM-1]if aM>=1 and r:testTMode(r:GET_OPCODE(aR))~=0 then return aR else return aQ end end;function t:need_value(aA,aS)while aS~=self.NO_JUMP do local a7=self:getjumpcontrol(aA,aS)if r:GET_OPCODE(a7)~="OP_TESTSET"then return true end;aS=self:getjump(aA,aS)end;return false end;function t:patchtestreg(aA,aT,aU)local a7=self:getjumpcontrol(aA,aT)if r:GET_OPCODE(a7)~="OP_TESTSET"then return false end;if aU~=r.NO_REG and aU~=r:GETARG_B(a7)then r:SETARG_A(a7,aU)else r:SET_OPCODE(a7,"OP_TEST")local z=r:GETARG_B(a7)r:SETARG_A(a7,z)r:SETARG_B(a7,0)end;return true end;function t:removevalues(aA,aS)while aS~=self.NO_JUMP do self:patchtestreg(aA,aS,r.NO_REG)aS=self:getjump(aA,aS)end end;function t:patchlistaux(aA,aS,aV,aU,aW)while aS~=self.NO_JUMP do local aX=self:getjump(aA,aS)if self:patchtestreg(aA,aS,aU)then self:fixjump(aA,aS,aV)else self:fixjump(aA,aS,aW)end;aS=aX end end;function t:dischargejpc(aA)self:patchlistaux(aA,aA.jpc,aA.pc,r.NO_REG,aA.pc)aA.jpc=self.NO_JUMP end;function t:patchlist(aA,aS,aY)if aY==aA.pc then self:patchtohere(aA,aS)else v(aY<aA.pc)self:patchlistaux(aA,aS,aY,r.NO_REG,aY)end end;function t:patchtohere(aA,aS)self:getlabel(aA)aA.jpc=self:concat(aA,aA.jpc,aS)end;function t:concat(aA,aZ,a_)if a_==self.NO_JUMP then return aZ elseif aZ==self.NO_JUMP then return a_ else local aS=aZ;local aX=self:getjump(aA,aS)while aX~=self.NO_JUMP do aS=aX;aX=self:getjump(aA,aS)end;self:fixjump(aA,aS,a_)end;return aZ end;function t:checkstack(aA,G)local b0=aA.freereg+G;if b0>aA.f.maxstacksize then if b0>=self.MAXSTACK then q:syntaxerror(aA.ls,"function or expression too complex")end;aA.f.maxstacksize=b0 end end;function t:reserveregs(aA,G)self:checkstack(aA,G)aA.freereg=aA.freereg+G end;function t:freereg(aA,aU)if not r:ISK(aU)and aU>=aA.nactvar then aA.freereg=aA.freereg-1;v(aU==aA.freereg)end end;function t:freeexp(aA,aB)if aB.k=="VNONRELOC"then self:freereg(aA,aB.info)end end;function t:addk(aA,b1,K)local l=aA.L;local b2=aA.h[b1.value]local aw=aA.f;if self:ttisnumber(b2)then return self:nvalue(b2)else b2={}self:setnvalue(b2,aA.nk)aA.h[b1.value]=b2;p:growvector(l,aw.k,aA.nk,aw.sizek,nil,r.MAXARG_Bx,"constant table overflow")aw.k[aA.nk]=K;local b3=aA.nk;aA.nk=aA.nk+1;return b3 end end;function t:stringK(aA,Y)local a9={}self:setsvalue(a9,Y)return self:addk(aA,a9,a9)end;function t:numberK(aA,al)local a9={}self:setnvalue(a9,al)return self:addk(aA,a9,a9)end;function t:boolK(aA,z)local a9={}self:setbvalue(a9,z)return self:addk(aA,a9,a9)end;function t:nilK(aA)local b1,K={},{}self:setnilvalue(K)self:sethvalue(b1,aA.h)return self:addk(aA,b1,K)end;function t:setreturns(aA,aB,b4)if aB.k=="VCALL"then r:SETARG_C(self:getcode(aA,aB),b4+1)elseif aB.k=="VVARARG"then r:SETARG_B(self:getcode(aA,aB),b4+1)r:SETARG_A(self:getcode(aA,aB),aA.freereg)t:reserveregs(aA,1)end end;function t:setoneret(aA,aB)if aB.k=="VCALL"then aB.k="VNONRELOC"aB.info=r:GETARG_A(self:getcode(aA,aB))elseif aB.k=="VVARARG"then r:SETARG_B(self:getcode(aA,aB),2)aB.k="VRELOCABLE"end end;function t:dischargevars(aA,aB)local b1=aB.k;if b1=="VLOCAL"then aB.k="VNONRELOC"elseif b1=="VUPVAL"then aB.info=self:codeABC(aA,"OP_GETUPVAL",0,aB.info,0)aB.k="VRELOCABLE"elseif b1=="VGLOBAL"then aB.info=self:codeABx(aA,"OP_GETGLOBAL",0,aB.info)aB.k="VRELOCABLE"elseif b1=="VINDEXED"then self:freereg(aA,aB.aux)self:freereg(aA,aB.info)aB.info=self:codeABC(aA,"OP_GETTABLE",0,aB.info,aB.aux)aB.k="VRELOCABLE"elseif b1=="VVARARG"or b1=="VCALL"then self:setoneret(aA,aB)else end end;function t:code_label(aA,aC,z,b5)self:getlabel(aA)return self:codeABC(aA,"OP_LOADBOOL",aC,z,b5)end;function t:discharge2reg(aA,aB,aU)self:dischargevars(aA,aB)local b1=aB.k;if b1=="VNIL"then self:_nil(aA,aU,1)elseif b1=="VFALSE"or b1=="VTRUE"then self:codeABC(aA,"OP_LOADBOOL",aU,aB.k=="VTRUE"and 1 or 0,0)elseif b1=="VK"then self:codeABx(aA,"OP_LOADK",aU,aB.info)elseif b1=="VKNUM"then self:codeABx(aA,"OP_LOADK",aU,self:numberK(aA,aB.nval))elseif b1=="VRELOCABLE"then local aM=self:getcode(aA,aB)r:SETARG_A(aM,aU)elseif b1=="VNONRELOC"then if aU~=aB.info then self:codeABC(aA,"OP_MOVE",aU,aB.info,0)end else v(aB.k=="VVOID"or aB.k=="VJMP")return end;aB.info=aU;aB.k="VNONRELOC"end;function t:discharge2anyreg(aA,aB)if aB.k~="VNONRELOC"then self:reserveregs(aA,1)self:discharge2reg(aA,aB,aA.freereg-1)end end;function t:exp2reg(aA,aB,aU)self:discharge2reg(aA,aB,aU)if aB.k=="VJMP"then aB.t=self:concat(aA,aB.t,aB.info)end;if self:hasjumps(aB)then local b6;local b7=self.NO_JUMP;local b8=self.NO_JUMP;if self:need_value(aA,aB.t)or self:need_value(aA,aB.f)then local b9=aB.k=="VJMP"and self.NO_JUMP or self:jump(aA)b7=self:code_label(aA,aU,0,1)b8=self:code_label(aA,aU,1,0)self:patchtohere(aA,b9)end;b6=self:getlabel(aA)self:patchlistaux(aA,aB.f,b6,aU,b7)self:patchlistaux(aA,aB.t,b6,aU,b8)end;aB.f,aB.t=self.NO_JUMP,self.NO_JUMP;aB.info=aU;aB.k="VNONRELOC"end;function t:exp2nextreg(aA,aB)self:dischargevars(aA,aB)self:freeexp(aA,aB)self:reserveregs(aA,1)self:exp2reg(aA,aB,aA.freereg-1)end;function t:exp2anyreg(aA,aB)self:dischargevars(aA,aB)if aB.k=="VNONRELOC"then if not self:hasjumps(aB)then return aB.info end;if aB.info>=aA.nactvar then self:exp2reg(aA,aB,aB.info)return aB.info end end;self:exp2nextreg(aA,aB)return aB.info end;function t:exp2val(aA,aB)if self:hasjumps(aB)then self:exp2anyreg(aA,aB)else self:dischargevars(aA,aB)end end;function t:exp2RK(aA,aB)self:exp2val(aA,aB)local b1=aB.k;if b1=="VKNUM"or b1=="VTRUE"or b1=="VFALSE"or b1=="VNIL"then if aA.nk<=r.MAXINDEXRK then if aB.k=="VNIL"then aB.info=self:nilK(aA)else aB.info=aB.k=="VKNUM"and self:numberK(aA,aB.nval)or self:boolK(aA,aB.k=="VTRUE")end;aB.k="VK"return r:RKASK(aB.info)end elseif b1=="VK"then if aB.info<=r.MAXINDEXRK then return r:RKASK(aB.info)end else end;return self:exp2anyreg(aA,aB)end;function t:storevar(aA,ba,bb)local b1=ba.k;if b1=="VLOCAL"then self:freeexp(aA,bb)self:exp2reg(aA,bb,ba.info)return elseif b1=="VUPVAL"then local aB=self:exp2anyreg(aA,bb)self:codeABC(aA,"OP_SETUPVAL",aB,ba.info,0)elseif b1=="VGLOBAL"then local aB=self:exp2anyreg(aA,bb)self:codeABx(aA,"OP_SETGLOBAL",aB,ba.info)elseif b1=="VINDEXED"then local aB=self:exp2RK(aA,bb)self:codeABC(aA,"OP_SETTABLE",ba.info,ba.aux,aB)else v(0)end;self:freeexp(aA,bb)end;function t:_self(aA,aB,bc)self:exp2anyreg(aA,aB)self:freeexp(aA,aB)local bd=aA.freereg;self:reserveregs(aA,2)self:codeABC(aA,"OP_SELF",bd,aB.info,self:exp2RK(aA,bc))self:freeexp(aA,bc)aB.info=bd;aB.k="VNONRELOC"end;function t:invertjump(aA,aB)local aM=self:getjumpcontrol(aA,aB.info)v(r:testTMode(r:GET_OPCODE(aM))~=0 and r:GET_OPCODE(aM)~="OP_TESTSET"and r:GET_OPCODE(aM)~="OP_TEST")r:SETARG_A(aM,r:GETARG_A(aM)==0 and 1 or 0)end;function t:jumponcond(aA,aB,be)if aB.k=="VRELOCABLE"then local bf=self:getcode(aA,aB)if r:GET_OPCODE(bf)=="OP_NOT"then aA.pc=aA.pc-1;return self:condjump(aA,"OP_TEST",r:GETARG_B(bf),0,be and 0 or 1)end end;self:discharge2anyreg(aA,aB)self:freeexp(aA,aB)return self:condjump(aA,"OP_TESTSET",r.NO_REG,aB.info,be and 1 or 0)end;function t:goiftrue(aA,aB)local aM;self:dischargevars(aA,aB)local b1=aB.k;if b1=="VK"or b1=="VKNUM"or b1=="VTRUE"then aM=self.NO_JUMP elseif b1=="VFALSE"then aM=self:jump(aA)elseif b1=="VJMP"then self:invertjump(aA,aB)aM=aB.info else aM=self:jumponcond(aA,aB,false)end;aB.f=self:concat(aA,aB.f,aM)self:patchtohere(aA,aB.t)aB.t=self.NO_JUMP end;function t:goiffalse(aA,aB)local aM;self:dischargevars(aA,aB)local b1=aB.k;if b1=="VNIL"or b1=="VFALSE"then aM=self.NO_JUMP elseif b1=="VTRUE"then aM=self:jump(aA)elseif b1=="VJMP"then aM=aB.info else aM=self:jumponcond(aA,aB,true)end;aB.t=self:concat(aA,aB.t,aM)self:patchtohere(aA,aB.f)aB.f=self.NO_JUMP end;function t:codenot(aA,aB)self:dischargevars(aA,aB)local b1=aB.k;if b1=="VNIL"or b1=="VFALSE"then aB.k="VTRUE"elseif b1=="VK"or b1=="VKNUM"or b1=="VTRUE"then aB.k="VFALSE"elseif b1=="VJMP"then self:invertjump(aA,aB)elseif b1=="VRELOCABLE"or b1=="VNONRELOC"then self:discharge2anyreg(aA,aB)self:freeexp(aA,aB)aB.info=self:codeABC(aA,"OP_NOT",0,aB.info,0)aB.k="VRELOCABLE"else v(0)end;aB.f,aB.t=aB.t,aB.f;self:removevalues(aA,aB.f)self:removevalues(aA,aB.t)end;function t:indexed(aA,am,b1)am.aux=self:exp2RK(aA,b1)am.k="VINDEXED"end;function t:constfolding(aj,bg,bh)local al;if not self:isnumeral(bg)or not self:isnumeral(bh)then return false end;local bi=bg.nval;local bj=bh.nval;if aj=="OP_ADD"then al=self:numadd(bi,bj)elseif aj=="OP_SUB"then al=self:numsub(bi,bj)elseif aj=="OP_MUL"then al=self:nummul(bi,bj)elseif aj=="OP_DIV"then if bj==0 then return false end;al=self:numdiv(bi,bj)elseif aj=="OP_MOD"then if bj==0 then return false end;al=self:nummod(bi,bj)elseif aj=="OP_POW"then al=self:numpow(bi,bj)elseif aj=="OP_UNM"then al=self:numunm(bi)elseif aj=="OP_LEN"then return false else v(0)al=0 end;if self:numisnan(al)then return false end;bg.nval=al;return true end;function t:codearith(aA,aj,bg,bh)if self:constfolding(aj,bg,bh)then return else local bk=aj~="OP_UNM"and aj~="OP_LEN"and self:exp2RK(aA,bh)or 0;local bl=self:exp2RK(aA,bg)if bl>bk then self:freeexp(aA,bg)self:freeexp(aA,bh)else self:freeexp(aA,bh)self:freeexp(aA,bg)end;bg.info=self:codeABC(aA,aj,0,bl,bk)bg.k="VRELOCABLE"end end;function t:codecomp(aA,aj,be,bg,bh)local bl=self:exp2RK(aA,bg)local bk=self:exp2RK(aA,bh)self:freeexp(aA,bh)self:freeexp(aA,bg)if be==0 and aj~="OP_EQ"then bl,bk=bk,bl;be=1 end;bg.info=self:condjump(aA,aj,be,bl,bk)bg.k="VJMP"end;function t:prefix(aA,aj,aB)local bh={}bh.t,bh.f=self.NO_JUMP,self.NO_JUMP;bh.k="VKNUM"bh.nval=0;if aj=="OPR_MINUS"then if not self:isnumeral(aB)then self:exp2anyreg(aA,aB)end;self:codearith(aA,"OP_UNM",aB,bh)elseif aj=="OPR_NOT"then self:codenot(aA,aB)elseif aj=="OPR_LEN"then self:exp2anyreg(aA,aB)self:codearith(aA,"OP_LEN",aB,bh)else v(0)end end;function t:infix(aA,aj,K)if aj=="OPR_AND"then self:goiftrue(aA,K)elseif aj=="OPR_OR"then self:goiffalse(aA,K)elseif aj=="OPR_CONCAT"then self:exp2nextreg(aA,K)elseif aj=="OPR_ADD"or aj=="OPR_SUB"or aj=="OPR_MUL"or aj=="OPR_DIV"or aj=="OPR_MOD"or aj=="OPR_POW"then if not self:isnumeral(K)then self:exp2RK(aA,K)end else self:exp2RK(aA,K)end end;t.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}t.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}t.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function t:posfix(aA,aj,bg,bh)local function bm(bg,bh)bg.k=bh.k;bg.info=bh.info;bg.aux=bh.aux;bg.nval=bh.nval;bg.t=bh.t;bg.f=bh.f end;if aj=="OPR_AND"then v(bg.t==self.NO_JUMP)self:dischargevars(aA,bh)bh.f=self:concat(aA,bh.f,bg.f)bm(bg,bh)elseif aj=="OPR_OR"then v(bg.f==self.NO_JUMP)self:dischargevars(aA,bh)bh.t=self:concat(aA,bh.t,bg.t)bm(bg,bh)elseif aj=="OPR_CONCAT"then self:exp2val(aA,bh)if bh.k=="VRELOCABLE"and r:GET_OPCODE(self:getcode(aA,bh))=="OP_CONCAT"then v(bg.info==r:GETARG_B(self:getcode(aA,bh))-1)self:freeexp(aA,bg)r:SETARG_B(self:getcode(aA,bh),bg.info)bg.k="VRELOCABLE"bg.info=bh.info else self:exp2nextreg(aA,bh)self:codearith(aA,"OP_CONCAT",bg,bh)end else local bn=self.arith_op[aj]if bn then self:codearith(aA,bn,bg,bh)else local bo=self.comp_op[aj]if bo then self:codecomp(aA,bo,self.comp_cond[aj],bg,bh)else v(0)end end end end;function t:fixline(aA,bp)aA.f.lineinfo[aA.pc-1]=bp end;function t:code(aA,a7,bp)local aw=aA.f;self:dischargejpc(aA)p:growvector(aA.L,aw.code,aA.pc,aw.sizecode,nil,p.MAX_INT,"code size overflow")aw.code[aA.pc]=a7;p:growvector(aA.L,aw.lineinfo,aA.pc,aw.sizelineinfo,nil,p.MAX_INT,"code size overflow")aw.lineinfo[aA.pc]=bp;local aM=aA.pc;aA.pc=aA.pc+1;return aM end;function t:codeABC(aA,a9,ab,z,n)v(r:getOpMode(a9)==r.OpMode.iABC)v(r:getBMode(a9)~=r.OpArgMask.OpArgN or z==0)v(r:getCMode(a9)~=r.OpArgMask.OpArgN or n==0)return self:code(aA,r:CREATE_ABC(a9,ab,z,n),aA.ls.lastline)end;function t:codeABx(aA,a9,ab,ac)v(r:getOpMode(a9)==r.OpMode.iABx or r:getOpMode(a9)==r.OpMode.iAsBx)v(r:getCMode(a9)==r.OpArgMask.OpArgN)return self:code(aA,r:CREATE_ABx(a9,ab,ac),aA.ls.lastline)end;function t:setlist(aA,bq,br,bs)local n=math.floor((br-1)/r.LFIELDS_PER_FLUSH)+1;local z=bs==p.LUA_MULTRET and 0 or bs;v(bs~=0)if n<=r.MAXARG_C then self:codeABC(aA,"OP_SETLIST",bq,z,n)else self:codeABC(aA,"OP_SETLIST",bq,z,0)self:code(aA,r:CREATE_Inst(n),aA.ls.lastline)end;aA.freereg=bq+1 end;p.LUA_QS=q.LUA_QS or"'%s'"p.SHRT_MAX=32767;p.LUAI_MAXVARS=200;p.LUAI_MAXUPVALUES=60;p.MAX_INT=q.MAX_INT or 2147483645;p.LUAI_MAXCCALLS=200;p.VARARG_HASARG=1;p.HASARG_MASK=2;p.VARARG_ISVARARG=2;p.VARARG_NEEDSARG=4;p.LUA_MULTRET=-1;function p:LUA_QL(x)return"'"..x.."'"end;function p:growvector(l,K,br,bt,am,bu,aB)if br>=bu then error(aB)end end;function p:newproto(l)local aw={}aw.k={}aw.sizek=0;aw.p={}aw.sizep=0;aw.code={}aw.sizecode=0;aw.sizelineinfo=0;aw.sizeupvalues=0;aw.nups=0;aw.upvalues={}aw.numparams=0;aw.is_vararg=0;aw.maxstacksize=0;aw.lineinfo={}aw.sizelocvars=0;aw.locvars={}aw.lineDefined=0;aw.lastlinedefined=0;aw.source=nil;return aw end;function p:int2fb(x)local aB=0;while x>=16 do x=math.floor((x+1)/2)aB=aB+1 end;if x<8 then return x else return(aB+1)*8+x-8 end end;function p:hasmultret(b1)return b1=="VCALL"or b1=="VVARARG"end;function p:getlocvar(aA,a7)return aA.f.locvars[aA.actvar[a7]]end;function p:checklimit(aA,K,Q,k)if K>Q then self:errorlimit(aA,Q,k)end end;function p:anchor_token(S)if S.t.token=="TK_NAME"or S.t.token=="TK_STRING"then end end;function p:error_expected(S,T)q:syntaxerror(S,string.format(self.LUA_QS.." expected",q:token2str(S,T)))end;function p:errorlimit(aA,bu,bv)local U=aA.f.linedefined==0 and string.format("main function has more than %d %s",bu,bv)or string.format("function at line %d has more than %d %s",aA.f.linedefined,bu,bv)q:lexerror(aA.ls,U,0)end;function p:testnext(S,n)if S.t.token==n then q:next(S)return true else return false end end;function p:check(S,n)if S.t.token~=n then self:error_expected(S,n)end end;function p:checknext(S,n)self:check(S,n)q:next(S)end;function p:check_condition(S,n,U)if not n then q:syntaxerror(S,U)end end;function p:check_match(S,bv,bw,bx)if not self:testnext(S,bv)then if bx==S.linenumber then self:error_expected(S,bv)else q:syntaxerror(S,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",q:token2str(S,bv),q:token2str(S,bw),bx))end end end;function p:str_checkname(S)self:check(S,"TK_NAME")local a8=S.t.seminfo;q:next(S)return a8 end;function p:init_exp(aB,b1,a7)aB.f,aB.t=t.NO_JUMP,t.NO_JUMP;aB.k=b1;aB.info=a7 end;function p:codestring(S,aB,Y)self:init_exp(aB,"VK",t:stringK(S.fs,Y))end;function p:checkname(S,aB)self:codestring(S,aB,self:str_checkname(S))end;function p:registerlocalvar(S,by)local aA=S.fs;local aw=aA.f;self:growvector(S.L,aw.locvars,aA.nlocvars,aw.sizelocvars,nil,self.SHRT_MAX,"too many local variables")aw.locvars[aA.nlocvars]={}aw.locvars[aA.nlocvars].varname=by;local bz=aA.nlocvars;aA.nlocvars=aA.nlocvars+1;return bz end;function p:new_localvarliteral(S,K,G)self:new_localvar(S,K,G)end;function p:new_localvar(S,name,G)local aA=S.fs;self:checklimit(aA,aA.nactvar+G+1,self.LUAI_MAXVARS,"local variables")aA.actvar[aA.nactvar+G]=self:registerlocalvar(S,name)end;function p:adjustlocalvars(S,bA)local aA=S.fs;aA.nactvar=aA.nactvar+bA;for a7=bA,1,-1 do self:getlocvar(aA,aA.nactvar-a7).startpc=aA.pc end end;function p:removevars(S,bB)local aA=S.fs;while aA.nactvar>bB do aA.nactvar=aA.nactvar-1;self:getlocvar(aA,aA.nactvar).endpc=aA.pc end end;function p:indexupvalue(aA,name,K)local aw=aA.f;for a7=0,aw.nups-1 do if aA.upvalues[a7].k==K.k and aA.upvalues[a7].info==K.info then v(aw.upvalues[a7]==name)return a7 end end;self:checklimit(aA,aw.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(aA.L,aw.upvalues,aw.nups,aw.sizeupvalues,nil,self.MAX_INT,"")aw.upvalues[aw.nups]=name;v(K.k=="VLOCAL"or K.k=="VUPVAL")aA.upvalues[aw.nups]={k=K.k,info=K.info}local bC=aw.nups;aw.nups=aw.nups+1;return bC end;function p:searchvar(aA,G)for a7=aA.nactvar-1,0,-1 do if G==self:getlocvar(aA,a7).varname then return a7 end end;return-1 end;function p:markupval(aA,bD)local bE=aA.bl;while bE and bE.nactvar>bD do bE=bE.previous end;if bE then bE.upval=true end end;function p:singlevaraux(aA,G,ba,bq)if aA==nil then self:init_exp(ba,"VGLOBAL",r.NO_REG)return"VGLOBAL"else local K=self:searchvar(aA,G)if K>=0 then self:init_exp(ba,"VLOCAL",K)if bq==0 then self:markupval(aA,K)end;return"VLOCAL"else if self:singlevaraux(aA.prev,G,ba,0)=="VGLOBAL"then return"VGLOBAL"end;ba.info=self:indexupvalue(aA,G,ba)ba.k="VUPVAL"return"VUPVAL"end end end;function p:singlevar(S,ba)local by=self:str_checkname(S)local aA=S.fs;if self:singlevaraux(aA,by,ba,1)=="VGLOBAL"then ba.info=t:stringK(aA,by)end end;function p:adjust_assign(S,bA,bF,aB)local aA=S.fs;local bG=bA-bF;if self:hasmultret(aB.k)then bG=bG+1;if bG<=0 then bG=0 end;t:setreturns(aA,aB,bG)if bG>1 then t:reserveregs(aA,bG-1)end else if aB.k~="VVOID"then t:exp2nextreg(aA,aB)end;if bG>0 then local aU=aA.freereg;t:reserveregs(aA,bG)t:_nil(aA,aU,bG)end end end;function p:enterlevel(S)S.L.nCcalls=S.L.nCcalls+1;if S.L.nCcalls>self.LUAI_MAXCCALLS then q:lexerror(S,"chunk has too many syntax levels",0)end end;function p:leavelevel(S)S.L.nCcalls=S.L.nCcalls-1 end;function p:enterblock(aA,bE,bH)bE.breaklist=t.NO_JUMP;bE.isbreakable=bH;bE.nactvar=aA.nactvar;bE.upval=false;bE.previous=aA.bl;aA.bl=bE;v(aA.freereg==aA.nactvar)end;function p:leaveblock(aA)local bE=aA.bl;aA.bl=bE.previous;self:removevars(aA.ls,bE.nactvar)if bE.upval then t:codeABC(aA,"OP_CLOSE",bE.nactvar,0,0)end;v(not bE.isbreakable or not bE.upval)v(bE.nactvar==aA.nactvar)aA.freereg=aA.nactvar;t:patchtohere(aA,bE.breaklist)end;function p:pushclosure(S,bd,K)local aA=S.fs;local aw=aA.f;self:growvector(S.L,aw.p,aA.np,aw.sizep,nil,r.MAXARG_Bx,"constant table overflow")aw.p[aA.np]=bd.f;aA.np=aA.np+1;self:init_exp(K,"VRELOCABLE",t:codeABx(aA,"OP_CLOSURE",0,aA.np-1))for a7=0,bd.f.nups-1 do local a9=bd.upvalues[a7].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"t:codeABC(aA,a9,0,bd.upvalues[a7].info,0)end end;function p:open_func(S,aA)local l=S.L;local aw=self:newproto(S.L)aA.f=aw;aA.prev=S.fs;aA.ls=S;aA.L=l;S.fs=aA;aA.pc=0;aA.lasttarget=-1;aA.jpc=t.NO_JUMP;aA.freereg=0;aA.nk=0;aA.np=0;aA.nlocvars=0;aA.nactvar=0;aA.bl=nil;aw.source=S.source;aw.maxstacksize=2;aA.h={}end;function p:close_func(S)local l=S.L;local aA=S.fs;local aw=aA.f;self:removevars(S,0)t:ret(aA,0,0)aw.sizecode=aA.pc;aw.sizelineinfo=aA.pc;aw.sizek=aA.nk;aw.sizep=aA.np;aw.sizelocvars=aA.nlocvars;aw.sizeupvalues=aw.nups;v(aA.bl==nil)S.fs=aA.prev;if aA then self:anchor_token(S)end end;function p:parser(l,F,y,name)local bI={}bI.t={}bI.lookahead={}local bJ={}bJ.upvalues={}bJ.actvar={}l.nCcalls=0;bI.buff=y;q:setinput(l,bI,F,name)self:open_func(bI,bJ)bJ.f.is_vararg=self.VARARG_ISVARARG;q:next(bI)self:chunk(bI)self:check(bI,"TK_EOS")self:close_func(bI)v(bJ.prev==nil)v(bJ.f.nups==0)v(bI.fs==nil)return bJ.f end;function p:field(S,K)local aA=S.fs;local bc={}t:exp2anyreg(aA,K)q:next(S)self:checkname(S,bc)t:indexed(aA,K,bc)end;function p:yindex(S,K)q:next(S)self:expr(S,K)t:exp2val(S.fs,K)self:checknext(S,"]")end;function p:recfield(S,bK)local aA=S.fs;local aU=S.fs.freereg;local bc,bL={},{}if S.t.token=="TK_NAME"then self:checklimit(aA,bK.nh,self.MAX_INT,"items in a constructor")self:checkname(S,bc)else self:yindex(S,bc)end;bK.nh=bK.nh+1;self:checknext(S,"=")local bM=t:exp2RK(aA,bc)self:expr(S,bL)t:codeABC(aA,"OP_SETTABLE",bK.t.info,bM,t:exp2RK(aA,bL))aA.freereg=aU end;function p:closelistfield(aA,bK)if bK.v.k=="VVOID"then return end;t:exp2nextreg(aA,bK.v)bK.v.k="VVOID"if bK.tostore==r.LFIELDS_PER_FLUSH then t:setlist(aA,bK.t.info,bK.na,bK.tostore)bK.tostore=0 end end;function p:lastlistfield(aA,bK)if bK.tostore==0 then return end;if self:hasmultret(bK.v.k)then t:setmultret(aA,bK.v)t:setlist(aA,bK.t.info,bK.na,self.LUA_MULTRET)bK.na=bK.na-1 else if bK.v.k~="VVOID"then t:exp2nextreg(aA,bK.v)end;t:setlist(aA,bK.t.info,bK.na,bK.tostore)end end;function p:listfield(S,bK)self:expr(S,bK.v)self:checklimit(S.fs,bK.na,self.MAX_INT,"items in a constructor")bK.na=bK.na+1;bK.tostore=bK.tostore+1 end;function p:constructor(S,am)local aA=S.fs;local bp=S.linenumber;local aM=t:codeABC(aA,"OP_NEWTABLE",0,0,0)local bK={}bK.v={}bK.na,bK.nh,bK.tostore=0,0,0;bK.t=am;self:init_exp(am,"VRELOCABLE",aM)self:init_exp(bK.v,"VVOID",0)t:exp2nextreg(S.fs,am)self:checknext(S,"{")repeat v(bK.v.k=="VVOID"or bK.tostore>0)if S.t.token=="}"then break end;self:closelistfield(aA,bK)local n=S.t.token;if n=="TK_NAME"then q:lookahead(S)if S.lookahead.token~="="then self:listfield(S,bK)else self:recfield(S,bK)end elseif n=="["then self:recfield(S,bK)else self:listfield(S,bK)end until not self:testnext(S,",")and not self:testnext(S,";")self:check_match(S,"}","{",bp)self:lastlistfield(aA,bK)r:SETARG_B(aA.f.code[aM],self:int2fb(bK.na))r:SETARG_C(aA.f.code[aM],self:int2fb(bK.nh))end;function p:parlist(S)local aA=S.fs;local aw=aA.f;local bN=0;aw.is_vararg=0;if S.t.token~=")"then repeat local n=S.t.token;if n=="TK_NAME"then self:new_localvar(S,self:str_checkname(S),bN)bN=bN+1 elseif n=="TK_DOTS"then q:next(S)self:new_localvarliteral(S,"arg",bN)bN=bN+1;aw.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;aw.is_vararg=aw.is_vararg+self.VARARG_ISVARARG else q:syntaxerror(S,"<name> or "..self:LUA_QL("...").." expected")end until aw.is_vararg~=0 or not self:testnext(S,",")end;self:adjustlocalvars(S,bN)aw.numparams=aA.nactvar-aw.is_vararg%self.HASARG_MASK;t:reserveregs(aA,aA.nactvar)end;function p:body(S,aB,bO,bp)local bP={}bP.upvalues={}bP.actvar={}self:open_func(S,bP)bP.f.lineDefined=bp;self:checknext(S,"(")if bO then self:new_localvarliteral(S,"self",0)self:adjustlocalvars(S,1)end;self:parlist(S)self:checknext(S,")")self:chunk(S)bP.f.lastlinedefined=S.linenumber;self:check_match(S,"TK_END","TK_FUNCTION",bp)self:close_func(S)self:pushclosure(S,bP,aB)end;function p:explist1(S,K)local G=1;self:expr(S,K)while self:testnext(S,",")do t:exp2nextreg(S.fs,K)self:expr(S,K)G=G+1 end;return G end;function p:funcargs(S,aw)local aA=S.fs;local bQ={}local bN;local bp=S.linenumber;local n=S.t.token;if n=="("then if bp~=S.lastline then q:syntaxerror(S,"ambiguous syntax (function call x new statement)")end;q:next(S)if S.t.token==")"then bQ.k="VVOID"else self:explist1(S,bQ)t:setmultret(aA,bQ)end;self:check_match(S,")","(",bp)elseif n=="{"then self:constructor(S,bQ)elseif n=="TK_STRING"then self:codestring(S,bQ,S.t.seminfo)q:next(S)else q:syntaxerror(S,"function arguments expected")return end;v(aw.k=="VNONRELOC")local bq=aw.info;if self:hasmultret(bQ.k)then bN=self.LUA_MULTRET else if bQ.k~="VVOID"then t:exp2nextreg(aA,bQ)end;bN=aA.freereg-(bq+1)end;self:init_exp(aw,"VCALL",t:codeABC(aA,"OP_CALL",bq,bN+1,2))t:fixline(aA,bp)aA.freereg=bq+1 end;function p:prefixexp(S,K)local n=S.t.token;if n=="("then local bp=S.linenumber;q:next(S)self:expr(S,K)self:check_match(S,")","(",bp)t:dischargevars(S.fs,K)elseif n=="TK_NAME"then self:singlevar(S,K)else q:syntaxerror(S,"unexpected symbol")end;return end;function p:primaryexp(S,K)local aA=S.fs;self:prefixexp(S,K)while true do local n=S.t.token;if n=="."then self:field(S,K)elseif n=="["then local bc={}t:exp2anyreg(aA,K)self:yindex(S,bc)t:indexed(aA,K,bc)elseif n==":"then local bc={}q:next(S)self:checkname(S,bc)t:_self(aA,K,bc)self:funcargs(S,K)elseif n=="("or n=="TK_STRING"or n=="{"then t:exp2nextreg(aA,K)self:funcargs(S,K)else return end end end;function p:simpleexp(S,K)local n=S.t.token;if n=="TK_NUMBER"then self:init_exp(K,"VKNUM",0)K.nval=S.t.seminfo elseif n=="TK_STRING"then self:codestring(S,K,S.t.seminfo)elseif n=="TK_NIL"then self:init_exp(K,"VNIL",0)elseif n=="TK_TRUE"then self:init_exp(K,"VTRUE",0)elseif n=="TK_FALSE"then self:init_exp(K,"VFALSE",0)elseif n=="TK_DOTS"then local aA=S.fs;self:check_condition(S,aA.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local bR=aA.f.is_vararg;if bR>=self.VARARG_NEEDSARG then aA.f.is_vararg=bR-self.VARARG_NEEDSARG end;self:init_exp(K,"VVARARG",t:codeABC(aA,"OP_VARARG",0,1,0))elseif n=="{"then self:constructor(S,K)return elseif n=="TK_FUNCTION"then q:next(S)self:body(S,K,false,S.linenumber)return else self:primaryexp(S,K)return end;q:next(S)end;function p:getunopr(aj)if aj=="TK_NOT"then return"OPR_NOT"elseif aj=="-"then return"OPR_MINUS"elseif aj=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;p.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function p:getbinopr(aj)local bS=self.getbinopr_table[aj]if bS then return bS else return"OPR_NOBINOPR"end end;p.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}p.UNARY_PRIORITY=8;function p:subexpr(S,K,bu)self:enterlevel(S)local bT=self:getunopr(S.t.token)if bT~="OPR_NOUNOPR"then q:next(S)self:subexpr(S,K,self.UNARY_PRIORITY)t:prefix(S.fs,bT,K)else self:simpleexp(S,K)end;local aj=self:getbinopr(S.t.token)while aj~="OPR_NOBINOPR"and self.priority[t.BinOpr[aj]+1][1]>bu do local bj={}q:next(S)t:infix(S.fs,aj,K)local bU=self:subexpr(S,bj,self.priority[t.BinOpr[aj]+1][2])t:posfix(S.fs,aj,K,bj)aj=bU end;self:leavelevel(S)return aj end;function p:expr(S,K)self:subexpr(S,K,0)end;function p:block_follow(T)if T=="TK_ELSE"or T=="TK_ELSEIF"or T=="TK_END"or T=="TK_UNTIL"or T=="TK_EOS"then return true else return false end end;function p:block(S)local aA=S.fs;local bE={}self:enterblock(aA,bE,false)self:chunk(S)v(bE.breaklist==t.NO_JUMP)self:leaveblock(aA)end;function p:check_conflict(S,bV,K)local aA=S.fs;local bG=aA.freereg;local bW=false;while bV do if bV.v.k=="VINDEXED"then if bV.v.info==K.info then bW=true;bV.v.info=bG end;if bV.v.aux==K.info then bW=true;bV.v.aux=bG end end;bV=bV.prev end;if bW then t:codeABC(aA,"OP_MOVE",aA.freereg,K.info,0)t:reserveregs(aA,1)end end;function p:assignment(S,bV,bA)local aB={}local n=bV.v.k;self:check_condition(S,n=="VLOCAL"or n=="VUPVAL"or n=="VGLOBAL"or n=="VINDEXED","syntax error")if self:testnext(S,",")then local bX={}bX.v={}bX.prev=bV;self:primaryexp(S,bX.v)if bX.v.k=="VLOCAL"then self:check_conflict(S,bV,bX.v)end;self:checklimit(S.fs,bA,self.LUAI_MAXCCALLS-S.L.nCcalls,"variables in assignment")self:assignment(S,bX,bA+1)else self:checknext(S,"=")local bF=self:explist1(S,aB)if bF~=bA then self:adjust_assign(S,bA,bF,aB)if bF>bA then S.fs.freereg=S.fs.freereg-(bF-bA)end else t:setoneret(S.fs,aB)t:storevar(S.fs,bV.v,aB)return end end;self:init_exp(aB,"VNONRELOC",S.fs.freereg-1)t:storevar(S.fs,bV.v,aB)end;function p:cond(S)local K={}self:expr(S,K)if K.k=="VNIL"then K.k="VFALSE"end;t:goiftrue(S.fs,K)return K.f end;function p:breakstat(S)local aA=S.fs;local bE=aA.bl;local bY=false;while bE and not bE.isbreakable do if bE.upval then bY=true end;bE=bE.previous end;if not bE then q:syntaxerror(S,"no loop to break")end;if bY then t:codeABC(aA,"OP_CLOSE",bE.nactvar,0,0)end;bE.breaklist=t:concat(aA,bE.breaklist,t:jump(aA))end;function p:whilestat(S,bp)local aA=S.fs;local bE={}q:next(S)local bZ=t:getlabel(aA)local b_=self:cond(S)self:enterblock(aA,bE,true)self:checknext(S,"TK_DO")self:block(S)t:patchlist(aA,t:jump(aA),bZ)self:check_match(S,"TK_END","TK_WHILE",bp)self:leaveblock(aA)t:patchtohere(aA,b_)end;function p:repeatstat(S,bp)local aA=S.fs;local c0=t:getlabel(aA)local c1,c2={},{}self:enterblock(aA,c1,true)self:enterblock(aA,c2,false)q:next(S)self:chunk(S)self:check_match(S,"TK_UNTIL","TK_REPEAT",bp)local b_=self:cond(S)if not c2.upval then self:leaveblock(aA)t:patchlist(S.fs,b_,c0)else self:breakstat(S)t:patchtohere(S.fs,b_)self:leaveblock(aA)t:patchlist(S.fs,t:jump(aA),c0)end;self:leaveblock(aA)end;function p:exp1(S)local aB={}self:expr(S,aB)local b1=aB.k;t:exp2nextreg(S.fs,aB)return b1 end;function p:forbody(S,bq,bp,bA,c3)local bE={}local aA=S.fs;self:adjustlocalvars(S,3)self:checknext(S,"TK_DO")local c4=c3 and t:codeAsBx(aA,"OP_FORPREP",bq,t.NO_JUMP)or t:jump(aA)self:enterblock(aA,bE,false)self:adjustlocalvars(S,bA)t:reserveregs(aA,bA)self:block(S)self:leaveblock(aA)t:patchtohere(aA,c4)local c5=c3 and t:codeAsBx(aA,"OP_FORLOOP",bq,t.NO_JUMP)or t:codeABC(aA,"OP_TFORLOOP",bq,0,bA)t:fixline(aA,bp)t:patchlist(aA,c3 and c5 or t:jump(aA),c4+1)end;function p:fornum(S,by,bp)local aA=S.fs;local bq=aA.freereg;self:new_localvarliteral(S,"(for index)",0)self:new_localvarliteral(S,"(for limit)",1)self:new_localvarliteral(S,"(for step)",2)self:new_localvar(S,by,3)self:checknext(S,'=')self:exp1(S)self:checknext(S,",")self:exp1(S)if self:testnext(S,",")then self:exp1(S)else t:codeABx(aA,"OP_LOADK",aA.freereg,t:numberK(aA,1))t:reserveregs(aA,1)end;self:forbody(S,bq,bp,1,true)end;function p:forlist(S,c6)local aA=S.fs;local aB={}local bA=0;local bq=aA.freereg;self:new_localvarliteral(S,"(for generator)",bA)bA=bA+1;self:new_localvarliteral(S,"(for state)",bA)bA=bA+1;self:new_localvarliteral(S,"(for control)",bA)bA=bA+1;self:new_localvar(S,c6,bA)bA=bA+1;while self:testnext(S,",")do self:new_localvar(S,self:str_checkname(S),bA)bA=bA+1 end;self:checknext(S,"TK_IN")local bp=S.linenumber;self:adjust_assign(S,3,self:explist1(S,aB),aB)t:checkstack(aA,3)self:forbody(S,bq,bp,bA-3,false)end;function p:forstat(S,bp)local aA=S.fs;local bE={}self:enterblock(aA,bE,true)q:next(S)local by=self:str_checkname(S)local n=S.t.token;if n=="="then self:fornum(S,by,bp)elseif n==","or n=="TK_IN"then self:forlist(S,by)else q:syntaxerror(S,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(S,"TK_END","TK_FOR",bp)self:leaveblock(aA)end;function p:test_then_block(S)q:next(S)local b_=self:cond(S)self:checknext(S,"TK_THEN")self:block(S)return b_ end;function p:ifstat(S,bp)local aA=S.fs;local c7=t.NO_JUMP;local c8=self:test_then_block(S)while S.t.token=="TK_ELSEIF"do c7=t:concat(aA,c7,t:jump(aA))t:patchtohere(aA,c8)c8=self:test_then_block(S)end;if S.t.token=="TK_ELSE"then c7=t:concat(aA,c7,t:jump(aA))t:patchtohere(aA,c8)q:next(S)self:block(S)else c7=t:concat(aA,c7,c8)end;t:patchtohere(aA,c7)self:check_match(S,"TK_END","TK_IF",bp)end;function p:localfunc(S)local K,z={},{}local aA=S.fs;self:new_localvar(S,self:str_checkname(S),0)self:init_exp(K,"VLOCAL",aA.freereg)t:reserveregs(aA,1)self:adjustlocalvars(S,1)self:body(S,z,false,S.linenumber)t:storevar(aA,K,z)self:getlocvar(aA,aA.nactvar-1).startpc=aA.pc end;function p:localstat(S)local bA=0;local bF;local aB={}repeat self:new_localvar(S,self:str_checkname(S),bA)bA=bA+1 until not self:testnext(S,",")if self:testnext(S,"=")then bF=self:explist1(S,aB)else aB.k="VVOID"bF=0 end;self:adjust_assign(S,bA,bF,aB)self:adjustlocalvars(S,bA)end;function p:funcname(S,K)local bO=false;self:singlevar(S,K)while S.t.token=="."do self:field(S,K)end;if S.t.token==":"then bO=true;self:field(S,K)end;return bO end;function p:funcstat(S,bp)local K,z={},{}q:next(S)local bO=self:funcname(S,K)self:body(S,z,bO,bp)t:storevar(S.fs,K,z)t:fixline(S.fs,bp)end;function p:exprstat(S)local aA=S.fs;local K={}K.v={}self:primaryexp(S,K.v)if K.v.k=="VCALL"then r:SETARG_C(t:getcode(aA,K.v),1)else K.prev=nil;self:assignment(S,K,1)end end;function p:retstat(S)local aA=S.fs;local aB={}local P,aJ;q:next(S)if self:block_follow(S.t.token)or S.t.token==";"then P,aJ=0,0 else aJ=self:explist1(S,aB)if self:hasmultret(aB.k)then t:setmultret(aA,aB)if aB.k=="VCALL"and aJ==1 then r:SET_OPCODE(t:getcode(aA,aB),"OP_TAILCALL")v(r:GETARG_A(t:getcode(aA,aB))==aA.nactvar)end;P=aA.nactvar;aJ=self.LUA_MULTRET else if aJ==1 then P=t:exp2anyreg(aA,aB)else t:exp2nextreg(aA,aB)P=aA.nactvar;v(aJ==aA.freereg-P)end end end;t:ret(aA,P,aJ)end;function p:statement(S)local bp=S.linenumber;local n=S.t.token;if n=="TK_IF"then self:ifstat(S,bp)return false elseif n=="TK_WHILE"then self:whilestat(S,bp)return false elseif n=="TK_DO"then q:next(S)self:block(S)self:check_match(S,"TK_END","TK_DO",bp)return false elseif n=="TK_FOR"then self:forstat(S,bp)return false elseif n=="TK_REPEAT"then self:repeatstat(S,bp)return false elseif n=="TK_FUNCTION"then self:funcstat(S,bp)return false elseif n=="TK_LOCAL"then q:next(S)if self:testnext(S,"TK_FUNCTION")then self:localfunc(S)else self:localstat(S)end;return false elseif n=="TK_RETURN"then self:retstat(S)return true elseif n=="TK_BREAK"then q:next(S)self:breakstat(S)return true else self:exprstat(S)return false end end;function p:chunk(S)local c9=false;self:enterlevel(S)while not c9 and not self:block_follow(S.t.token)do c9=self:statement(S)self:testnext(S,";")v(S.fs.f.maxstacksize>=S.fs.freereg and S.fs.freereg>=S.fs.nactvar)S.fs.freereg=S.fs.nactvar end;self:leavelevel(S)end;q:init()local ca={}function dump(B,name)name=name or'iffunzz was here!'local cb=o:init(o:make_getF(B),nil)if not cb then return end;local bd=p:parser(ca,cb,nil,"@"..name)local an,y=s:make_setS()s:dump(ca,bd,an,y)return y.data end;return encrypt(dump(b),"encode")elseif a=="hlPtj7fBg8HhE9HDEpS1"then local cc={"ABC","ABx","ABC","ABC","ABC","ABx","ABC","ABx","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","AsBx","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","AsBx","AsBx","ABC","ABC","ABC","ABx","ABC"}local function cd(ce,G,cf)if cf then local cg=0;local ch=0;for a7=G,cf do cg=cg+2^ch*cd(ce,a7)ch=ch+1 end;return cg else local ci=2^(G-1)return ce%(ci+ci)>=ci and 1 or 0 end end;local cj=encrypt(b)local function ck(cl)local cm=1;local cn=false;local co;local cp;local cq,cr;local cs,ct,cu,cv,cw;do function cs()local ab=cl:byte(cm,cm)cm=cm+1;return ab end;function ct()local ab,z,n,cx=cl:byte(cm,cm+3)cm=cm+4;return cx*16777216+n*65536+z*256+ab end;function cu()local ab=ct()local z=ct()return z*4294967296+ab end;function cv()local ab=ct()local z=ct()return(-2*cd(z,32)+1)*2^(cd(z,21,31)-1023)*((cd(z,1,20)*2^32+ab)/2^52+1)end;function cw(R)local f;if R then f=cl:sub(cm,cm+R-1)cm=cm+R else R=cr()if R==0 then return end;f=cl:sub(cm,cm+R-1)cm=cm+R end;return f end end;local function cy()local cz;local cA={}local cB={}local cC={}local cD={lines={}}cz={instructions=cA,constants=cB,prototypes=cC,debug=cD}local cE;cz.name=cw()cz.first_line=cq()cz.last_line=cq()if cz.name then cz.name=cz.name:sub(1,-2)end;cz.upvalues=cs()cz.arguments=cs()cz.varg=cs()cz.stack=cs()do cE=cq()for a7=1,cE do local cF={}local A=ct()local cG=cd(A,1,6)local type=cc[cG+1]cF.opcode=cG;cF.type=type;cF.A=cd(A,7,14)if type=="ABC"then cF.B=cd(A,24,32)cF.C=cd(A,15,23)elseif type=="ABx"then cF.Bx=cd(A,15,32)elseif type=="AsBx"then cF.sBx=cd(A,15,32)-131071 end;cA[a7]=cF end end;do cE=cq()for a7=1,cE do local cH={}local type=cs()cH.type=type;if type==1 then cH.data=cs()~=0 elseif type==3 then cH.data=cv()elseif type==4 then cH.data=cw():sub(1,-2)end;cB[a7-1]=cH end end;do cE=cq()for a7=1,cE do cC[a7-1]=cy()end end;do local A=cD.lines;cE=cq()for a7=1,cE do A[a7]=ct()end;cE=cq()for a7=1,cE do cw():sub(1,-2)ct()ct()end;cE=cq()for a7=1,cE do cw()end end;return cz end;do assert(cw(4)=="\27Lua","Lua bytecode expected.")assert(cs()==0x51,"Only Lua 5.1 is supported.")cs()cn=cs()==0;co=cs()cp=cs()if co==4 then cq=ct elseif co==8 then cq=cu else error("Unsupported bytecode target platform")end;if cp==4 then cr=ct elseif cp==8 then cr=cu else error("Unsupported bytecode target platform")end;assert(cw(3)=="\4\8\0","Unsupported bytecode target platform")end;return cy()end;local function cI(...)local n=select("#",...)local am={...}return n,am end;local cJ=ck(cj)local function cK(cL,cM)local cA=cL.instructions;local cB=cL.constants;local cC=cL.prototypes;local cN,cO;local cP;local cQ=1;local cR,cS;local cT={[0]=function(cF)cN[cF.A]=cN[cF.B]end,[1]=function(cF)cN[cF.A]=cB[cF.Bx].data end,[2]=function(cF)cN[cF.A]=cF.B~=0;if cF.C~=0 then cQ=cQ+1 end end,[3]=function(cF)local cN=cN;for a7=cF.A,cF.B do cN[a7]=nil end end,[4]=function(cF)cN[cF.A]=cM[cF.B]end,[5]=function(cF)local bc=cB[cF.Bx].data;cN[cF.A]=cP[bc]end,[6]=function(cF)local aL=cF.C;local cN=cN;aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=cN[cF.B][aL]end,[7]=function(cF)local bc=cB[cF.Bx].data;cP[bc]=cN[cF.A]end,[8]=function(cF)cM[cF.B]=cN[cF.A]end,[9]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A][aK]=aL end,[10]=function(cF)cN[cF.A]={}end,[11]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN=cN;aK=cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[aC+1]=aK;cN[aC]=aK[aL]end,[12]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=aK+aL end,[13]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=aK-aL end,[14]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=aK*aL end,[15]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=aK/aL end,[16]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=aK%aL end,[17]=function(cF)local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]cN[cF.A]=aK^aL end,[18]=function(cF)cN[cF.A]=-cN[cF.B]end,[19]=function(cF)cN[cF.A]=not cN[cF.B]end,[20]=function(cF)cN[cF.A]=#cN[cF.B]end,[21]=function(cF)local aK=cF.B;local Z=cN[aK]for a7=aK+1,cF.C do Z=Z..cN[a7]end;cN[cF.A]=Z end,[22]=function(cF)cQ=cQ+cF.sBx end,[23]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aC=aC~=0;if aK>255 then aK=cB[aK-256].data else aK=cN[aK]end;if aL>255 then aL=cB[aL-256].data else aL=cN[aL]end;if aK==aL~=aC then cQ=cQ+1 end end,[24]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aC=aC~=0;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]if aK<aL~=aC then cQ=cQ+1 end end,[25]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN,cB=cN,cB;aC=aC~=0;aK=aK>255 and cB[aK-256].data or cN[aK]aL=aL>255 and cB[aL-256].data or cN[aL]if aK<=aL~=aC then cQ=cQ+1 end end,[26]=function(cF)local aC=cN[cF.A]if not not aC==(cF.C==0)then cQ=cQ+1 end end,[27]=function(cF)local cN=cN;local aK=cN[cF.B]if not not aK==(cF.C==0)then cQ=cQ+1 else cN[cF.A]=aK end end,[28]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN=cN;local bQ,cU;local bu,cV;bQ={}if aK~=1 then if aK~=0 then bu=aC+aK-1 else bu=cO end;cV=0;for a7=aC+1,bu do cV=cV+1;bQ[cV]=cN[a7]end;bu,cU=cI(cN[aC](unpack(bQ,1,bu-aC)))else bu,cU=cI(cN[aC]())end;cO=aC-1;if aL~=1 then if aL~=0 then bu=aC+aL-2 else bu=bu+aC end;cV=0;for a7=aC,bu do cV=cV+1;cN[a7]=cU[cV]end end end,[29]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN=cN;local bQ,cU;local cO,bu,cV=cO;bQ={}if aK~=1 then if aK~=0 then bu=aC+aK-1 else bu=cO end;cV=0;for a7=aC+1,bu do cV=cV+1;bQ[#bQ+1]=cN[a7]end;cU={cN[aC](unpack(bQ,1,bu-aC))}else cU={cN[aC]()}end;return true,cU end,[30]=function(cF)local aC=cF.A;local aK=cF.B;local cN=cN;local bu;local cV,cW;if aK==1 then return true end;if aK==0 then bu=cO else bu=aC+aK-2 end;cW={}local cV=0;for a7=aC,bu do cV=cV+1;cW[cV]=cN[a7]end;return true,cW end,[31]=function(cF)local aC=cF.A;local cN=cN;local cX=cN[aC+2]local cm=cN[aC]+cX;cN[aC]=cm;if cX>0 then if cm<=cN[aC+1]then cQ=cQ+cF.sBx;cN[aC+3]=cm end else if cm>=cN[aC+1]then cQ=cQ+cF.sBx;cN[aC+3]=cm end end end,[32]=function(cF)local aC=cF.A;local cN=cN;cN[aC]=cN[aC]-cN[aC+2]cQ=cQ+cF.sBx end,[33]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN=cN;local aP=aC+2;local Z={cN[aC](cN[aC+1],cN[aC+2])}for a7=1,aL do cN[aP+a7]=Z[a7]end;if cN[aC+3]~=nil then cN[aC+2]=cN[aC+3]else cQ=cQ+1 end end,[34]=function(cF)local aC=cF.A;local aK=cF.B;local aL=cF.C;local cN=cN;if aL==0 then error("NYI: extended SETLIST")else local aP=(aL-1)*50;local am=cN[aC]if aK==0 then aK=cO end;for a7=1,aK do am[aP+a7]=cN[aC+a7]end end end,[35]=function(cF)io.stderr:write("NYI: CLOSE")io.stderr:flush()end,[36]=function(cF)local cY=cC[cF.Bx]local cA=cA;local cN=cN;local cZ={}local c_=setmetatable({},{__index=function(am,b1)local bY=cZ[b1]return bY.segment[bY.offset]end,__newindex=function(am,b1,K)local bY=cZ[b1]bY.segment[bY.offset]=K end})for a7=1,cY.upvalues do local d0=cA[cQ]if d0.opcode==0 then cZ[a7-1]={segment=cN,offset=d0.B}elseif cA[cQ].opcode==4 then cZ[a7-1]={segment=cM,offset=d0.B}end;cQ=cQ+1 end;local L,bd=cK(cY,c_)cN[cF.A]=bd end,[37]=function(cF)local aC=cF.A;local aK=cF.B;local cN,cR=cN,cR;for a7=aC,aC+(aK>0 and aK-1 or cS)do cN[a7]=cR[a7-aC]end end}local function cV()local cA=cA;local cF,ab,z;while true do cF=cA[cQ]cQ=cQ+1;ab,z=cT[cF.opcode](cF)if ab then return z end end end;local function bd(...)local d1={}local d2={}cO=-1;cN=setmetatable(d1,{__index=d2,__newindex=function(am,b1,K)if b1>cO and K then cO=b1 end;d2[b1]=K end})local bQ={...}cR={}cS=select("#",...)-1;for a7=0,cS do d1[a7]=bQ[a7+1]cR[a7]=bQ[a7+1]end;cP=getfenv()cQ=1;local d3=coroutine.create(cV)local ab,z=coroutine.resume(d3)if ab then if z then return unpack(z)end;return end end;return bd()end;cK(cJ)return end end
